#!/usr/bin/perl
use strict;
use warnings;

my $IPMAGIC_NAME = "raspi";

my @packagesToRemove = qw(
  libtag1-rusxmms
  wolfram-engine
);

my $normalPackages = {
  '1' => [qw(
    vim-gtk rsync wget git openvpn screen
  )],
  '2' => [qw(
    libterm-readkey-perl libtext-csv-perl libts0
  )],
  '3' => [qw(
    x11vnc lsof psmisc zip unzip parted
    fonts-droid-fallback fonts-vlgothic
    fonts-opensymbol fonts-liberation fonts-linuxlibertine
    fonts-sil-gentium fonts-sil-gentium-basic
    fonts-inconsolata
  )],
  '4' => [qw(
    xinit midori time streamer
  )],
  '5' => [qw(
    mplayer mpv man python-pip alsa-utils xdotool unclutter xscreensaver
  )],
  '6' => [qw(
    libcec4 libcec-dev
  )],
};
my $extraPackages = {};

my $repoDir = 'repos';

sub runRemote(@){
  my @cmd = ("ipmagic", $IPMAGIC_NAME, "-u", "root", @_);
  system @cmd;
  die "error running '@cmd'\n" if $? != 0;
}
sub readProcRemote(@){
  my $cmd = "ipmagic $IPMAGIC_NAME -u root @_";
  my $out = `$cmd`;
  die "error running '$cmd'\n" if $? != 0;
  return $out;
}
sub host(){
  my $host = `ipmagic $IPMAGIC_NAME --host`;
  chomp $host;
  return $host;
}

sub installPackages($);
sub removePackages();
sub setupRepos();

sub main(@){
  my $arg = shift;
  $arg = 'all' if not defined $arg;
  my $valid = join '|', qw(all repos packages extra remove);
  if(@_ > 0 or $arg !~ /^($valid)/){
    die "Usage: $0 TYPE {type must start with one of: $valid}\n";
  }
  if($arg =~ /^(all|repos)/){
    if(setupRepos()){
      runRemote "apt-get update";
    }
  }
  installPackages($normalPackages) if $arg =~ /^(all|packages)/;
  removePackages() if $arg =~ /^(all|remove)/;
  installPackages($extraPackages) if $arg =~ /^(all|extra)/;
}


sub getRepos(){
  #important to sort the files and not the lines
  my $cmd = "'ls /etc/apt/sources.list.d/*.list | sort | xargs cat'";
  return readProcRemote $cmd;
}

sub setupRepos(){
  if(not -d $repoDir){
    print "skipping repo setup; \"$repoDir\" doesnt exist\n";
    return 0;
  }
  my $before = getRepos();
  my $host = host();

  print "Copying $repoDir => remote\n";
  system "scp $repoDir/* root\@$host:/etc/apt/sources.list.d/";
  print "\n\n";

  print "Content of the copied lists:\n";
  system "cat $repoDir/*.list";
  print "\n\n";

  runRemote '
    echo INSTALLING KEYS:
    for x in /etc/apt/sources.list.d/*.key; do
      echo $x
      apt-key add "$x"
    done
  ';

  my $after = getRepos();
  return $before ne $after;
}

sub installPackages($){
  my $pkgGroups = shift;
  print "\n\n";
  for my $pkgGroup(sort keys %$pkgGroups){
    my @packages = @{$$pkgGroups{$pkgGroup}};
    print "\n\nInstalling group[$pkgGroup]:\n----\n@packages\n----\n";
    runRemote ''
      . "yes |"
      . " apt-get install"
      . " -y --allow-unauthenticated"
      . " @packages";
  }
}

sub removePackages(){
  if(@packagesToRemove == 0){
    print "skipping removal, no packages to remove\n";
    return;
  }
  print "\n\nInstalling the deps for removed packages to unmarkauto\n";
  my %deps;
  my $dependsOut = readProcRemote "apt-cache depends @packagesToRemove";
  for my $line(split /[\r\n]+/, $dependsOut){
    if($line =~ /^\s*Depends: ([^<>]*)/){
      my $pkg = $1;
      chomp $pkg;
      $deps{$pkg} = 1;
    }
  }
  for my $pkg(@packagesToRemove){
    delete $deps{$pkg};
  }
  my $depInstallCmd = "apt-get install \\\n";
  for my $dep(keys %deps){
    $depInstallCmd .= "  $dep \\\n";
  }
  print $depInstallCmd;
  runRemote $depInstallCmd;

  print "\n\nChecking uninstalled packages\n";
  my $removeCmd = "dpkg --purge --force-all";
  for my $pkg(@packagesToRemove){
    $removeCmd .= " $pkg";
  }
  if(@packagesToRemove > 0){
    runRemote $removeCmd;
  }
}

&main(@ARGV);
