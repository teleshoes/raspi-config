#!/usr/bin/python
#Copyright 2013 Elliot Wolk
# based on:
#
# HD44780 LCD Test Script for
# Raspberry Pi
#
# Author : Matt Hawkins
# Site   : http://www.raspberrypi-spy.co.uk
#
# Date   : 03/08/2012
#

# The wiring for the LCD is as follows:
# 1 : GND
# 2 : 5V
# 3 : Contrast (0-5V)*
# 4 : RS (Register Select)
# 5 : R/W (Read Write)       - GROUND THIS PIN
# 6 : Enable or Strobe
# 7 : Data Bit 0             - NOT USED IN 4 BIT
# 8 : Data Bit 1             - NOT USED IN 4 BIT
# 9 : Data Bit 2             - NOT USED IN 4 BIT
# 10: Data Bit 3             - NOT USED IN 4 BIT
# 11: Data Bit 4
# 12: Data Bit 5
# 13: Data Bit 6
# 14: Data Bit 7
# 15: LCD Backlight +5V**
# 16: LCD Backlight GND

import RPi.GPIO as GPIO
import sys
import time
import getpass
from subprocess import call

CONFIG = { 'MODE_8BIT': True         #4bit = false, 8bit = true
         , 'LCD_CHAR_WIDTH': 20      #length of the lines
         , 'LCD_LINE_ADDR_1': 0x80   #RAM address for line#1
         , 'LCD_LINE_ADDR_2': 0xC0   #RAM address for line#2
         , 'PAGE' : None
         }

LCD_LINE_ADDRS = [ CONFIG['LCD_LINE_ADDR_1']
                 , CONFIG['LCD_LINE_ADDR_2']
                 , CONFIG['LCD_LINE_ADDR_1'] + CONFIG['LCD_CHAR_WIDTH']
                 , CONFIG['LCD_LINE_ADDR_2'] + CONFIG['LCD_CHAR_WIDTH']
                 ]


# Define GPIO to LCD mapping
PINS = { 'RS':  2
       , 'E':   3
       , 'D0':  14  #not used in 4bit
       , 'D1':  15  #not used in 4bit
       , 'D2':  18 #not used in 4bit
       , 'D3':  23 #not used in 4bit
       , 'D4':  24
       , 'D5':  25
       , 'D6':  8
       , 'D7':  7
       , 'LED': 4
       }

LCD_CHR = True
LCD_CMD = False

E_PULSE = 0.001

CMD_FCT_SET_8BIT_2LINE_5X7 = 0x38
CMD_FCT_SET_4BIT_2LINE_5X7 = 0x28
CMD_RESET = 0x01
CMD_ENTRY_MODE = 0x06
CMD_DISPLAY_ON_CURSOR_OFF = 0x0C

def ensureRoot():
  if getpass.getuser() != 'root':
    print "rerunning as root..\n"
    cmd = ["sudo"] + sys.argv
    sys.exit(call(cmd))

def main(args):
  if len(args) >= 1 and (args[0] == '-h' or args[0] == '--help'):
    die()

  ensureRoot()

  if len(args) >= 2 and args[0] == '--mode':
    if args[1] == '8':
      CONFIG['MODE_8BIT'] = True
      args = args[2:]
    elif args[1] == '4':
      CONFIG['MODE_8BIT'] = False
      args = args[2:]
    else:
      die()

  if len(args) >= 2 and args[0] == '-e':
    try:
      PINS['E'] = int(args[1])
      args = args[2:]
    except:
      die()

  if len(args) >= 2 and args[0] == '--page':
    try:
      CONFIG['PAGE'] = int(args[1])
      args = args[2:]
    except:
      die()

  initGPIO()

  if len(args) == 1 and args[0] == '--off':
    ledToggle(False)
  elif len(args) == 1 and args[0] == '--on':
    ledToggle(True)
  elif len(args) == 1 and args[0] == '--blink':
    ledBlink(3, 0.1)
  elif len(args) >= 1:
    setText(args)
  else:
    die()

def die():
  print >> sys.stderr, ("Usage:\n"
    + "  [--mode BITS] [-e E-PIN] [--page PAGE] LINE [LINE LINE LINE ..]\n"
    + "    set 2-row LCD text\n"
    + "  [--on | --off]\n"
    + "    turn LED backlight on/off\n"
    + "  --blink\n"
    + "    blink LED backlight, preserving initial backlight\n"
    + "\n"
    + "  BITS:  either '4' or '8' for 4bit or 8bit mode\n"
    + "  E-PIN: GPIO pin for the LCD enable pin\n"
    + "  PAGE: split LINEs into pages and display the indicated page\n"
    + "        the same page is displayed for each line:\n"
    + "          if one line has fewer pages than another line,\n"
    + "          and the selected page is after the last page,\n"
    + "          the FIRST page for that line is selected\n"
    + "        pages are zero-indexed, and modular:\n"
    + "          if there are 3 pages, p0 and p3 are both the first page,\n"
    + "          and p2 and p5 are both the last page\n"
    + "        if page is specified, ~ is prepended/appended to the page\n"
    + "          if there are additional pages before/after it\n"
    + "        the page width is " + str(CONFIG['LCD_CHAR_WIDTH']) + "\n"
    )
  sys.exit(1)

def initGPIO():
  GPIO.setmode(GPIO.BCM)       # Use BCM GPIO numbers
  for pin in PINS.values():
    GPIO.setup(pin, GPIO.OUT)

def ledBlink(count, delay):
  status = ledRead()
  for i in range(count):
    ledToggle(not status)
    time.sleep(delay)
    ledToggle(status)
    time.sleep(delay)

def ledToggle(on):
  GPIO.output(PINS['LED'], on)

def ledRead():
  return not GPIO.input(PINS['LED'])

def setText(lines):
  lcd_init()

  if CONFIG['PAGE'] != None:
    lines = paginate(lines, CONFIG['PAGE'])

  for lineAddr in zip(lines, LCD_LINE_ADDRS):
    (line, addr) = lineAddr
    line = line[0 : CONFIG['LCD_CHAR_WIDTH']]
    lcd_byte(addr, LCD_CMD)
    lcd_string(line)

def lcd_init():
  #magic commands
  lcd_byte(0x33,LCD_CMD)
  lcd_byte(0x32,LCD_CMD)

  if CONFIG['MODE_8BIT']:
    lcd_byte(CMD_FCT_SET_8BIT_2LINE_5X7,LCD_CMD)
  else:
    lcd_byte(CMD_FCT_SET_4BIT_2LINE_5X7,LCD_CMD)

  lcd_byte(CMD_DISPLAY_ON_CURSOR_OFF,LCD_CMD)
  lcd_byte(CMD_ENTRY_MODE,LCD_CMD)
  lcd_byte(CMD_RESET,LCD_CMD)

def lcd_string(message):
  for c in message:
    lcd_byte(ord(c),LCD_CHR)


def lcd_byte(bits, mode):
  if CONFIG['MODE_8BIT']:
    lcd_byte_8bit(bits, mode)
  else:
    lcd_byte_4bit(bits, mode)

def lcd_byte_8bit(bits, mode):
  GPIO.output(PINS['RS'], mode) # RS

  GPIO.output(PINS['D0'], bits&0x01)
  GPIO.output(PINS['D1'], bits&0x02)
  GPIO.output(PINS['D2'], bits&0x04)
  GPIO.output(PINS['D3'], bits&0x08)
  GPIO.output(PINS['D4'], bits&0x10)
  GPIO.output(PINS['D5'], bits&0x20)
  GPIO.output(PINS['D6'], bits&0x40)
  GPIO.output(PINS['D7'], bits&0x80)

  toggleEnable()

def lcd_byte_4bit(bits, mode):
  GPIO.output(PINS['RS'], mode) # RS

  # High bits
  GPIO.output(PINS['D4'], bits&0x10)
  GPIO.output(PINS['D5'], bits&0x20)
  GPIO.output(PINS['D6'], bits&0x40)
  GPIO.output(PINS['D7'], bits&0x80)

  toggleEnable()

  # Low bits
  GPIO.output(PINS['D4'], bits&0x01)
  GPIO.output(PINS['D5'], bits&0x02)
  GPIO.output(PINS['D6'], bits&0x04)
  GPIO.output(PINS['D7'], bits&0x08)

  toggleEnable()

def toggleEnable():
  GPIO.output(PINS['E'], True)
  time.sleep(E_PULSE)
  GPIO.output(PINS['E'], False)

def getPages(line):
  remLen = len(line)
  pages = []
  pos = 0

  w = CONFIG['LCD_CHAR_WIDTH']

  if 0 < remLen and remLen <= w:
    pages.append(line[pos : pos+w])
    pos += w
    remLen -= w
  elif remLen > w:
    pages.append(line[pos : pos+w-1] + "~")
    pos += w-1
    remLen -= w-1

  while remLen > 0:
    if 0 < remLen and remLen <= w-1:
      pages.append("~" + line[pos : pos+w-1])
      pos += w-1
      remLen -= w-1
    elif remLen > w-1:
      pages.append("~" + line[pos : pos+w-2] + "~")
      pos += w-2
      remLen -= w-2

  if len(pages) == 0:
    pages.append("")

  return pages

def paginate(lines, page):
  linePages = map(getPages, lines)
  maxPages = max(map(len, linePages))

  page %= maxPages

  selectedPages = []
  for pages in linePages:
    if page < len(pages):
      selectedPages.append(pages[page])
    else:
      selectedPages.append(pages[0])

  return selectedPages

if __name__ == '__main__':
  main(sys.argv[1:])

