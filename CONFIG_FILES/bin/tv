#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(sleep);

my $stateFile = "/tmp/tv-last-state";
my $readPin = 0; #BCM 17 => GPIO0 => wiringpi 0
my $writePin = 2; #BCM 21/27 => GPIO2 => wiringpi 2

my $delayMs = 500;
my $stateMismatchDelayMs = 3000;

my $okCmd = join "|", qw(push|toggle|get|on|off);

my $usage = "Usage:
  $0 [push|toggle]   {default command}
    write 1 to wiringpi#$writePin
    sleep $delayMs ms
    write 0 to wiringpi#$writePin
    toggles 'on' <=> 'off' for last intended state in $stateFile

  $0 get
    read wiringpi#$readPin and print 'on' for 1 and 'off' for 0
    exit with code 0 for 'on' and 1 for 'off'

  $0 on
    do 'get': if pin is 1, do nothing, else do 'push'
      check to make sure 'get' matches $stateFile
      if it does not, merely wait and do 'get' again
    stores 'on' for last intended state in $stateFile

  $0 off
    do 'get': if pin is 0, do nothing, else do 'push'
      check to make sure 'get' matches $stateFile
      if it does not, merely wait and do 'get' again
    stores 'off' for last intended state in $stateFile
";

sub get();
sub pushButton();
sub run(@);
sub readProc(@);
sub readLastState();
sub writeLastState($);

sub main(@){
  my $arg = shift;
  $arg = 'push' if not defined $arg;
  die $usage if @_ > 0 or $arg !~ /^($okCmd)$/;

  if($arg =~ /^(push|toggle)$/){
    writeLastState(not readLastState());
    pushButton();
  }else{
    my $isOn = get();
    my $wasOn = readLastState();
    if((not $isOn and $wasOn) or ($isOn and not $wasOn)){
      print "state/pin mismatch: wait ${stateMismatchDelayMs}ms and recheck\n";
      sleep $stateMismatchDelayMs/1000.0;
      $isOn = get();
    }
    if($arg =~ /^(on)$/){
      if(not $isOn){
        pushButton();
      }else{
        print "skipping\n";
      }
      writeLastState(1);
    }elsif($arg =~ /^(off)$/){
      if($isOn){
        pushButton();
      }else{
        print "skipping\n";
      }
      writeLastState(0);
    }elsif($arg =~ /^(get)$/){
      print $isOn ? 'on' : 'off';
      print "\n";
      exit $isOn ? 0 : 1;
    }
  }
}

sub get(){
  run "gpio", "mode", $readPin, "in";
  my $status = readProc "gpio", "read", $readPin;
  chomp $status;
  die "ERROR: gpio read fail\n" if $status !~ /^(0|1)$/;
  return $status;
}

sub pushButton(){
  run "gpio", "mode", $writePin, "out";
  run "gpio", "write", $writePin, "1";
  print "sleeping for $delayMs ms\n";
  sleep $delayMs/1000.0;
  run "gpio", "write", $writePin, "0";
}

sub run(@){
  print "@_\n";
  system @_;
}

sub readProc(@){
  print "@_\n";
  return `@_`;
}

sub readLastState(){
  return 0 if not -f $stateFile;
  open FH, "< $stateFile" or die "Could not read $stateFile\n";
  my $state = <FH>;
  close FH;
  return $state =~ /^on/ ? 1 : 0;
}
sub writeLastState($){
  my $state = shift;
  open FH, "> $stateFile" or die "Could not write to $stateFile\n";
  print FH $state ? "on\n" : "off\n";
  close FH;
}
&main(@ARGV);
